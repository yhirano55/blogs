+++
date = "2015-09-24T13:17:39+09:00"
title = "［読書］UNIXという考え方"
description = "［読書］UNIXという考え方"
tags = ["読書"]

+++

半年程前に購入した『UNIXという考え方』だが、読もう読もうと思いつつも、必ずと言っていいほど、イントロダクション辺りで睡魔に襲われ、読めずじまいだったが、この度、ようやく読了したので、そのエッセンスや感銘を受けた箇所をメモしていく。

[asin:4274064069:detail]

購入前から名著とは聞いていたものの、実際に読んでみると、現在から遡ること14年前の2001年に出版されたとは思えないくらいの、<b>錆びない考え方（思想・哲学）</b>が書かれていた。

## 不親切なコンセプト

UNIXを他のOSと比較したとき、ユーザー想定が極端に違っていた。

> UNIXは「ユーザーは、自分が何をしているかを分かっている」との前提に立っている。（_P.1 イントロダクション_）

この前提があるので、<b>余計なものは作らない</b>という考えを元々持っている。

エクストリーム・プログラミングにおける原則、<b>YAGNI</b>に相当する考えだ。

> "You ain't gonna need it"、縮めて YAGNI とは、機能は実際に必要となるまでは追加しないのがよいとする、エクストリーム・プログラミングにおける原則である。（[YAGNI - Wikipedia](https://ja.wikipedia.org/wiki/YAGNI)）

こうした不親切さから、他のOSとは大きく差が開くことになり、大学などの研究機関やホビーユース以外での、ビジネスユースでは敬遠されてきたという。

だが、この不親切なコンセプトこそが、ソフトウェアにおけるシンプルな哲学をもたらしている。

## UNIXの9つの考え方

UNIXの基本思想は次の通り。

> 1. スモール・イズ・ビューティフル（小さいものは美しい）
> 2. 一つのプログラムには一つのことをうまくやらせる
> 3. できるだけ早く試作する
> 4. 効率より移植性を優先する
> 5. 数値データはASCIIフラットファイルに保存する
> 6. ソフトウェアを梃子（てこ）として使う
> 7. シェルスクリプトによって梃子の効果と移植性を高める
> 8. 過度の対話的インタフェースを避ける
> 9. すべてのプログラムをフィルタとして設計する
>
> （_P.8-9 第1章 UNIXの考え方_）

## どうして、小ささは美しいのか?

日本語の諺では「大は小を兼ねる」と言うが、UNIXの場合、大よりも小を推奨する。

> プログラムを書くときは小さなものから始めて、それを小さなままに保っておく。...中略...一つの巨大なプログラムにしようとする誘惑に負けないで、シンプルさを追求する。（P.14 第2章 人類にとっての小さな一歩）

これはなぜか?

とても分かりやすい話だが、巨大なプログラムは保守がしにくく、バグが含まれたとき、いろいろ厄介なことが多い。

そのため、小ささを保つことで以下のメリットをもたらす。

1. プログラムの目的が明確になる
2. 保守がしやすくなる
3. 分かりやすくなる
4. 他のプログラムと組み合わせやすくなる

巨大なプログラムは変更しにくい。だから、UNIXでは「<b>仕様をがっちり固めて、設計も完璧にして、さあコードを書くぞ</b>」という理想主義よりも、「<b>未来のことはわからない。だから今日できることをしっかりやろう</b>」という現実主義を採用している。

> 未来に目を向けよう。未来は、思っているより早く来る。（P.22 第2章 人類にとっての小さな一歩）

そのときの「ぼくがかんがえたさいきょうの〜」は、あっと言う間に枯れて、新たな「さいきょう」が生まれてくる。

それが、進歩や淘汰という自然な摂理ではある。

## ラピッドプロトタイピング

UNIXの思想において、先に挙げた「未来」に対する見方同様、「現実をどう見るか」が大きな鍵を握る。

変化は多く、最初から上手くいかないことが多いのが現実で、C言語を作ったデニス・リッチーでさえ、最初から完璧なプロダクトを作ったわけではないと言う。

だから、UNIXの思想では、「<b>できるだけ早く試作せよ</b>」とメッセージを送る。

> 「できるだけ早く」とは、本当に「できるだけ早く」ということだ。「大至急」だ。アプリケーションの立案に少しの時間をかけ、あとはまっしぐらに進むだけだ。命をかけてコードを書く。端末が熱いうちにキーボードを打つ。1ナノ秒も無駄にする時間はない。（P.31 第3章 楽しみと実益をかねた早めの試作）

なぜか? 完璧を求めることには無駄が多く、余計なリスクが減らせるからだ。

> 正しい設計が一つしかないのに対し、間違った設計は何百通りもある。（P.32 第3章 楽しみと実益をかねた早めの試作）

## システム・ライフサイクル

個人的に最も感銘を受けたのが、プロダクト・ライフサイクルに似た、システム・ライフサイクルの考え方だ。

ちなみにプロダクト・ライフサイクルは、次のような意味を示す。

> 製品ライフサイクル（Product life cycle）とはマーケティング用語の1つで、製品が市場に登場してから退場するまでの間を指し、普通は各製品に対してこの間の売上と利益の変化に着目して、最適のマーケティング戦略を構築するための基本的な情報となる。（[製品ライフサイクル - Wikipedia](https://ja.wikipedia.org/wiki/%E8%A3%BD%E5%93%81%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB)）

UNIXでは、システムのライフサイクルは「人間の作るシステムは人間に似る」とし、成長期・成熟期・老年期と、3つのフェーズに分割する。それはちょうど、プロダクト・ライフサイクルで言うところの、導入期・成長期・成熟期に相当する。

最初のフェーズは、<b>何よりもコンセプトやアイディアが重要</b>だ。美しい設計はクソ食らえで、締め切りに負われ、余裕がない状態でこそ、想像力に火がつき、生まれるものだと言う。作り手は、最少人数で、たいてい一人だ。この段階では、『<b>アイディアは素晴らしいが、いろいろと正しくない、クソコード</b>』とみなされるかもしれない。だが、そのアイディアさえ素晴らしければ、多くの人々の頭脳で、「もしも、これを使ったら…」と創造の刺激をもたらすことになる。

次のフェーズは、システムのコンセプトやアイディアに魅了された人が集い、「足し算」を行っていく。この段階では、<b>最初のシステムに対する批判家も多く現れ、本来のコンセプトとは離れた、「再設計」や「余計な足し算」</b>まで行われ、混沌とした「痛み」をもたらすことになる。人間で言うところの「成長痛」にあたる。

さんざん痛みに耐えに耐え、ようやくたどり着いた次のフェーズでは、先のフェーズでさんざん振り回され、余計なものが多く加えられ、当初のシステムの魅力を失った状態から始まる。もう、先のフェーズでコンセプトに魅了された人々は、そこにはおらず、<b>「原点に立ち返って、本来の目的を果たそう」という意志をもった人、あるいは、先のフェーズで「大火傷」した人</b>が集まる。真のシステムはここで誕生する。

## これからも錆びない考え方

以上、感銘を受けた箇所をピックアップしたが、同書は今後も錆びずに、哲学的なメッセージを数多く示唆してくれるだろう（人生の時々で、受け取る側の気づきもきっと変わるはず）。

手元に置いて時折読んでは、最初に読んだときの感動を呼び起こし、システムを作ることやコードを書くことについて、じっくりと考えてみたい。

